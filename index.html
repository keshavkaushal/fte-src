<!DOCTYPE html>
<html>
<head>
    <script src="phaser.min.js"></script>
    <script src="Midi.min.js"></script>
    <script src="Tone.min.js"></script>
</head>
<body style="margin: 1px; overflow: hidden; background: #000">

    <style media='screen' type='text/css'>
          @font-face {
            font-family: arcade;
            src: url('thin.ttf');
            font-weight: 400;
            font-weight: normal;
          }
    </style>
    <div style="font-family:arcade; position:absolute; left:-1000px; visibility:hidden;">.</div>
    <input style="display:none" type="file" id="filereader">
    <script>

        var config = {
            type: Phaser.AUTO,
            backgroundColor: '#222',
            scale: {
                mode: Phaser.Scale.FIT,
                parent: 'phaser-example',
                autoCenter: Phaser.Scale.CENTER_BOTH,
                width: 1600,
                height: 900
            },
            scene: {
                create: create,
                update: update,
                preload: preload,
            }
        };

        var MIDI_LOADED = false;
        var TICKRATE = 1;
        var RESET_TICKRATE = 1; 
        var PAUSED = true;
        var ACTIVE_TRACK = 0;
        var triggered_notes = new Set();
        var prev_active_keys = [];
        var pause;
        var play;

        var graphics;
        var statics;
        var seek_rect;
        var tick = 0;
        var MIDI;
        var colours = [[0xA3D2CA, 0x5EAAA8], [0xA685E2, 0x6155A6], [0xF2AAAA, 0xE36387], [0x8B5E83, 0xD6B0B1]]
        var the_keys = Array(88).fill([])
        
        var game = new Phaser.Game(config);

        const synth = new Tone.PolySynth().toDestination();
        const sampler = new Tone.Sampler({
            urls: {
                A0: "A0.mp3",
                C1: "C1.mp3",
                "D#1": "Ds1.mp3",
                "F#1": "Fs1.mp3",
                A1: "A1.mp3",
                C2: "C2.mp3",
                "D#2": "Ds2.mp3",
                "F#2": "Fs2.mp3",
                A2: "A2.mp3",
                C3: "C3.mp3",
                "D#3": "Ds3.mp3",
                "F#3": "Fs3.mp3",
                A3: "A3.mp3",
                C4: "C4.mp3",
                "D#4": "Ds4.mp3",
                "F#4": "Fs4.mp3",
                A4: "A4.mp3",
                C5: "C5.mp3",
                "D#5": "Ds5.mp3",
                "F#5": "Fs5.mp3",
                A5: "A5.mp3",
                C6: "C6.mp3",
                "D#6": "Ds6.mp3",
                "F#6": "Fs6.mp3",
                A6: "A6.mp3",
                C7: "C7.mp3",
                "D#7": "Ds7.mp3",
                "F#7": "Fs7.mp3",
                A7: "A7.mp3",
                C8: "C8.mp3"
            },
            release: 1,
            baseUrl: "https://tonejs.github.io/audio/salamander/"
        }).toDestination();

        function make_the_keys_map(){

            const black = [1, 4, 6, 9, 11, 13, 16, 18, 21, 23, 25, 28, 30, 33, 35, 37, 40, 42, 45, 47, 49, 52, 54, 57, 59, 61, 64, 66, 69, 71, 73, 76, 78, 81, 83, 85];
            const white = [0, 2, 3, 5, 7, 8, 10, 12, 14, 15, 17, 19, 20, 22, 24, 26, 27, 29, 31, 32, 34, 36, 38, 39, 41, 43, 44, 46, 48, 50, 51, 53, 55, 56, 58, 60, 62, 63, 65, 67, 68, 70, 72, 74, 75, 77, 79, 80, 82, 84, 86, 87];

            for (let i = 0; i < 52; i++)
            {
                the_keys[white[i]] = [0, (i*30.7)+5, 760, 25, 135];
            }

            black_keys_order = [
            'y',
            'n', 'y', 'y', 'n', 'y', 'y', 'y',
            'n', 'y', 'y', 'n', 'y', 'y', 'y',
            'n', 'y', 'y', 'n', 'y', 'y', 'y',
            'n', 'y', 'y', 'n', 'y', 'y', 'y',
            'n', 'y', 'y', 'n', 'y', 'y', 'y',
            'n', 'y', 'y', 'n', 'y', 'y', 'y',
            'n', 'y', 'y', 'n', 'y', 'y', 'y'
            ];

            counter = 0;

            for (let i = 0; i < 52; i++)
            {
                if (black_keys_order[i] == 'y')
                {
                    the_keys[black[counter]] = [1, (i*30.7)+25, 760, 17, 90]
                    counter ++
                }
            }  
        }

        function just_white()
        {
            graphics.fillStyle(0xffffff, 1);
            for (key of the_keys)
            {
                if (key[0] === 0)
                {
                    graphics.fillRect(key[1], key[2], key[3], key[4])
                }
            }
        }

        function just_black()
        {
            graphics.fillStyle(0x333333, 1);
            for (key of the_keys)
            {
                if (key[0] === 1)
                {
                    graphics.fillRect(key[1], key[2], key[3], key[4])
                }
            }
        }

        document.getElementById("filereader").onchange = function(e)
        {
            if (e.target.files.length > 0)
            {
                const reader = new FileReader();
                reader.onload = function(e)
                {
                    in_midi = new Midi(e.target.result);
                    out_midi = preprocess_midi(in_midi)
                    MIDI = out_midi
                    
                    tick = 0
                    MIDI_LOADED = true;
                    TICKRATE    = (MIDI.durationTicks / MIDI.duration) / 60
                    RESET_TICKRATE = (MIDI.durationTicks / MIDI.duration) / 60

                    if (PAUSED) {
                        playpause();
                    }
                }
                reader.readAsArrayBuffer(e.target.files[0]);
            }
        }

        function preprocess_midi (in_midi)
        {
            // WHAT IS THE SHORTEST NOTE IN THE WHOLE PIECE?
            var shortest_note = null;
            for (in_track of in_midi.tracks) {
                for (in_note of in_track.notes) {
                    if (shortest_note)
                    {
                        if (in_note.durationTicks < shortest_note && in_note.durationTicks > 4)
                        {
                            shortest_note = in_note.durationTicks;
                        }
                    } else {
                        shortest_note = in_note.durationTicks
                    } 
                }
            }

            console.log(shortest_note)
            // RESIZE THE ENTIRE MIDI BY NORMALISING THE SHORTEST NOTE TO BE 20px
            resize_factor = 20 / shortest_note

            end_midi = {
                "tracks": [],
                "duration": in_midi.duration,
                "durationTicks": in_midi.durationTicks * resize_factor
            }

            for (in_track of in_midi.tracks)
            {
                if (in_track.notes.length > 0)
                {
                    out_notes = []

                    for (in_note of in_track.notes)
                    {
                        out_note = {"midi": in_note.midi, "ticks": in_note.ticks * resize_factor, "durationTicks": in_note.durationTicks * resize_factor - 8}

                        out_notes.push(out_note)
                    }
                    
                    out_track = {"notes": out_notes}
                    end_midi.tracks.push(out_track)
                }
            }
            return end_midi
        }

        function preload()
        {
            this.load.image('play', '/playtext.png');
        }

        function create ()
        {
            seek_rect = this.add.graphics();
            graphics = this.add.graphics();
            statics = this.add.graphics();

            make_the_keys_map();

            // THE BARS TO HELP VIEWING NOTES
            seek_rect.fillStyle(0x555555, 1);
            var c_line = 64
            for (var i = 0; i < 8; i++) {
                seek_rect.fillRect(c_line, 0, 2, 900);
                c_line += 215
            }
            
            seek_rect.fillStyle(0x333333, 1);
            var e_line = 156
            for (var i = 0; i < 8; i++) {
                seek_rect.fillRect(e_line, 0, 2, 900);
                e_line += 215
            }

            graphics.fillStyle(0x111111, 1);
            graphics.fillRect(0, 758, 1600, 142)
            just_white();
            just_black();

            statics.fillStyle(0x111111, 0.8);
            statics.fillRect(0, 0, 1600, 100);

            graphics.fillStyle(0x333333, 1);
            seeker = this.add.rectangle(800, 150, 1600, 100, 0x333333, 0.5);
            const y_button_position = 50;

            // BUTTON OUTLINES FOR UPLOAD AND ABOUT
            statics.fillStyle(0x333333, 0.8);
            statics.fillRoundedRect(10, 10, 180, 80, 8)
            statics.fillRoundedRect(200, 10, 160, 80, 8)

            statics.fillRoundedRect(710, 10, 160, 80, 8)

            statics.fillRoundedRect(1510, 10, 80, 80, 8)
            statics.fillRoundedRect(1300, 10, 200, 80, 8)
            statics.fillRoundedRect(1210, 10, 80, 80, 8)

            // BUTTON OUTLINE FOR PLAY/PAUSE
            playpause_container = this.add.rectangle(800, 50, 160, 80, 5, 0xffffff)
            playpause_container.setInteractive().on('pointerdown', () => playpause());
            
            this.add.triangle(765, 50, 0, 50, 50, 25, 0, 0, 0xffffff)
            this.add.rectangle(820, 50, 15, 55, 0xffffff)
            this.add.rectangle(840, 50, 15, 55, 0xffffff)

            var text = this.add.text(30, 15, "Upload", { font: "100px arcade", fill: "#FFFFFF", align: "center"});
            text.setInteractive().on('pointerdown', () => upload_trigger());

            var about = this.add.text(220, 15, "About", { font: "100px arcade", fill: "#FFFFFF", align: "center"});

            this.add.text(1050, 15, "Speed:", { font: "100px arcade", fill: "#FFFFFF", align: "center"});

            reset = this.add.text(1340, 15, "Reset", { font: "100px arcade", fill: "#FFFFFF", align: "center"});
            reset.setInteractive().on('pointerdown', () => reset_speed());

            ff = this.add.text(1535, 10, "+", { font: "120px arcade", fill: "#FFFFFF", align: "center"});
            ff.setInteractive().on('pointerdown', () => speedup());

            rw = this.add.text(1235, 10, "-", { font: "120px arcade", fill: "#FFFFFF", align: "center"});
            rw.setInteractive().on('pointerdown', () => slowdown());

            seeker.setInteractive().on('pointerdown', function (pointer) {
                if (MIDI_LOADED)
                {
                    tick = (pointer.worldX / 1600) * (MIDI.durationTicks + 758);
                }
            });
        }

        function upload_trigger ()
        {
            document.getElementById('filereader').click()
        }

        function reset_speed ()
        {
            TICKRATE = RESET_TICKRATE.valueOf();
        }

        function speedup ()
        {
            TICKRATE = TICKRATE * 2;
        }

        function slowdown ()
        {
            TICKRATE = TICKRATE / 2;
        }

        function playpause ()
        {
            PAUSED = !PAUSED;
        }

        function update ()
        {
            if (MIDI_LOADED)
            {
                graphics.clear();

                vn_ak = get_visible_notes_and_active_keys();
                visible_notes = vn_ak[0]
                active_keys = vn_ak[1]
                
                trigger_notes(active_keys)

                falling_notes(visible_notes);
                graphics.fillStyle(0x111111, 1);
                graphics.fillRect(0, 758, 1600, 142)
                
                just_white();
                
                graphics.fillStyle(0xa5fed2, 1);
                active_white(active_keys, visible_notes);

                just_black();

                graphics.fillStyle(0x62B38A, 1);
                active_black(active_keys, visible_notes);

                seek_point = tick / (MIDI.durationTicks + 758) * 1600

                // graphics.fillStyle(0x333333, 1);
                // graphics.fillRect(0, 100, 1600, 100);
                graphics.fillStyle(0x999999, 0.3);
                graphics.fillRect(0, 100, seek_point, 100);

                if (tick > MIDI.durationTicks + 758)
                {
                    if (!PAUSED)
                    {
                        playpause();
                    }
                    
                }
            }

            if (!PAUSED) {
                tick = tick + TICKRATE;
            }
        }

        function get_visible_notes_and_active_keys()
        {
            visible_notes = []
            active_keys = []
            var track_counter = 0;

            for (track of MIDI.tracks)
            {
                for (note of track.notes)
                {
                    note["track"] = track_counter;

                    bottom_of_note = tick - note.ticks;
                    top_of_note = bottom_of_note - note.durationTicks;

                    // if (bottom_of_note > -2000)
                    if (bottom_of_note > 0)
                    {
                        if (top_of_note < 758) {
                            visible_notes.push(note)
                        }

                    }

                    if (bottom_of_note > 758)
                    {
                        if (top_of_note < 758)
                        {
                            active_keys.push(note)
                            
                        }
                    }
                }

                track_counter ++
            }

            return [visible_notes, active_keys];
        }

        

        function trigger_notes(active_keys)
        {
            var difference = new Set()

            if (prev_active_keys) {
                var act = new Set(active_keys)
                var pre = new Set(prev_active_keys)

                difference = new Set([...act].filter(x => !pre.has(x)));
            } else {
                difference = new Set(active_keys)
            }
            prev_active_keys = [...active_keys]
            
            if (difference.size > 0)
            {

                var frequencies_to_play = []

                for (newnote of difference) {
                    power = (newnote.midi - 69) / 12
                    frequency = Math.pow(2, power) * 440
                    frequencies_to_play.push(frequency)
                }

                if (!PAUSED){
                    sampler.triggerAttackRelease(frequencies_to_play, 0.4);
                }
            }
        }

        function falling_notes(visible_notes)
        {
            for (note of visible_notes)
            {
                the_key = the_keys[note.midi - 21]
                x = the_key[1];
                y = tick - note.ticks - note.durationTicks;
                
                graphics.fillStyle(colours[note.track][the_key[0]])
                graphics.fillRect(the_key[1], y, the_key[3], note.durationTicks, 4);
            }
        }

        function active_white(active_keys, visible_notes)
        {
            for (key of active_keys)
            {
                the_key = the_keys[key.midi - 21]

                if (the_key[0] === 0)
                {
                    graphics.fillStyle(colours[key.track][0], 1)
                    graphics.fillRect(the_key[1], the_key[2], the_key[3], the_key[4]);
                }
            }
        }

        function active_black(active_keys, visible_notes)
        {
            for (key of active_keys)
            {
                the_key = the_keys[key.midi - 21]

                if (the_key[0] === 1)
                {
                    graphics.fillStyle(colours[key.track][1])
                    graphics.fillRect(the_key[1], the_key[2], the_key[3], the_key[4]);
                }
            }
        }
    </script>
</body>
</html>